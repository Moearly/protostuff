#summary java_bean_model compiler provides you with flexible and inheritable schema generation for your separated\independent models

= Flexible and inheritable schema generation =

*java_bean_model* compiler is designed to give you a lot of flexibility for generated schemas through out
polymorphism and extended use of annotations. You can subclass result schema and change the way fields are 
written or read, change which fields should be written and which should not, how instances of deserialized 
objects should be generated.

This compiler is based on basic *java_bean* compiler code. The main purpose is to generate schemas
for described messages to be compatible to your models. It implies you already have your models in your 
project and you don't want to change them much.

_Note. Models it self can be generated too if required. But a lot of specific features for that compiler
on models generation are not implemented yet. So the models you can get from it is much alike java_bean
will give to you._

Second goal of this compiler is to give you some work around for handling inheritance in your models.
This also requires subclassing of generated schemas and explicitly specifying of how to behave with it.

= Features =
 
== Schema generation ==
 * inheritable schemas
 * overridable reads/writes
 * native type cast support on read/write int32
 * native byte[] fields support
 * accessors (is/set/get), direct field access to public fields
 * renaming of field map
 * collection fields with base class types 

== Model generation ==
 
 * immutable messages models (as option)
 * copy()
 * builder
 * toString()
 * native types for fields (support for existing annotation in schema @Byte, @Bytes, @Short, etc)

None of this model generation features are implemented yet.


= Usage =

 * Schema and Model classes will always be generated in separate files as separate classes.
 * Schema names will always be generated in form of: {{{ <message name><message suffix>Schema}}}. This is to separate names of generated models and schemas. Suffix can be defined following way (suffix term is used in postfix meaning) (options with higher priority overrides options with lower priority): 
 {{{
       // from highest priority to lowest 
       option msuffix = "Suffix"; // can only be provided inside of message body
       option java_model_suffix = "Suffix"; // can be provided inside of message body
       option <message name>.suffix = "Suffix for this certain message";  // in global namespace or in module properties
       option java_model_suffix = "Suffix"; // in global namespace, in module properties
 }}}
 * Model names will always be generated in form of: {{{ <message package><message name><message suffix>}}}. Package is defined much alike schema Suffix. Package should be always end up with DOT.
   {{{ 
       // from highest priority to lowest 
       option mpackage = "com.package."; // can only be provided inside of message body
       option java_model_package = "com.package."; // can be provided inside of message body
       option <message name>.package = "package for this certain message.";  // in global namespace or in module properties
       option java_model_package = "com.package."; // in global namespace, in module properties
   }}} 
 * if {{{ @Import(a="com.text.blah", b="org.text.blah", ...) }}} is specified on a message, all values of params of this attribute will be included in an import section of the file.
 * if {{{ @Transient }}} is specified on a message or enum block, it will be skipped for generation. Nothing will be generated for that.
 * {{{ option java_schema_field_accessors=true; }}} can be used in module properties, or global namespace, or message body to specify that accessors methods should be used for accessing model fields on  reading/writing. _Note. Currently fields in a message will be used directly in one case only, when there is no of this option applied anywhere to certain message._
 * Pipe schema generation is untouched. I don't know is it useable currently in this version.
 * For a fields you can specify following attributes: {{{ @Byte, @Short, @Char }}} to ask the compiler to provide needed casts on reads/writes. This is needed if you have native java values in your models. As you know there are no any protobuf field vals less then 32 bit per int. There is only one optimization for negative values. So, you can use this, to be compatible.
 * There is {{{ @Bytes }}} attribute for your needs also. As you know default behaviour of protostuff is to provide you with ByteString array fields. This is not what you would like to get often. So, you can use this, if you have {{{ byte[] }}} fields in your models.
 * There is {{{ @NoCheck }}} attrubute. This is special for cases when you would like to omit nullity-check on a repeated field in mergeFrom body switch case. As you know, protostuff will check on deserialization of the repeated value whether it's target collection is not null or not, and will write a code for creating it if it is null. The implementation that is used for creation is {{{ ArrayList<T> }}}. This is not always what you want from it. So you can skip this check, if you need.
 * If you want to rename you field in field-map (to provide another names in json/xml) you can use {{{ @Field(alias = "...") }}} attribute. Often you will want your serialized fields names to be different from what names your fields have in a model (java class).
 * There is also special attribute for repeated field called {{{ @Collection(name, type, checkFunction) }}}. It should be every argument of this attribute is optional, but it is useless without them. This attr will allow you to have custom name for your repeated field accessors (setName, getName i.e.), custom _superclass_ as generic argument to be used for collection initialization (and de/serialization) and special check function (that will return always false by default - yes, you should override it) that can help you to filter instances of your subclasses of collection superclass to be written with this specific field schema. This can be used to work around some inheritance issues, when you would like to have class hierarchy stored in one collection superclass.

= Sample: simple =

{{{
package game.data.model.proto;

option java_schema_field_accessors = true;
option java_model_package = "game.data.model.";
option java_model_suffix = "";

message Cowardice {
    required int32 defenderId = 1;

    required int32 attackerId = 2;

    @Byte
    required int32 score = 3;

    required int32 old = 4;

    @Byte
    required int32 lastResult = 5;
}

message CowardiceCacheEntry {
    option mpackage = "game.data.model.cache.";

    required int32 heroId = 1;

    repeated Cowardice cowardices  = 2;
}
}}}