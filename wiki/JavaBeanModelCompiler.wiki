#summary java_bean_model compiler provides you with flexible and inheritable schema generation for your separated\independent models

= Flexible and inheritable schema generation =

*java_bean_model* compiler is designed to give you a lot of flexibility for generated schemas through out
polymorphism and extended use of annotations. You can subclass result schema and change the way fields are 
written or read, change which fields should be written and which should not, how instances of deserialized 
objects should be generated.

This compiler is based on basic *java_bean* compiler code. The main purpose is to generate schemas
for described messages to be compatible to your models. It implies you already have your models in your 
project and you don't want to change them much.

_Note. Models it self can be generated too if required. But a lot of specific features for that compiler
on models generation are not implemented yet. So the models you can get from it is much alike java_bean
will give to you._

Second goal of this compiler is to give you some work around for handling inheritance in your models.
This also requires subclassing of generated schemas and explicitly specifying of how to behave with it.

= Features =
 
== Schema generation ==
 * inheritable schemas
 * overridable reads/writes
 * native type cast support on read/write int32
 * native byte[] fields support
 * accessors (is/set/get), direct field access to public fields
 * renaming of field map
 * collection fields with base class types 

== Model generation ==
 
 * immutable messages models (as option)
 * copy()
 * builder
 * toString()
 * native types for fields (support for existing annotation in schema @Byte, @Bytes, @Short, etc)

None of this model generation features are implemented yet.


= Usage =

 * Schema and Model classes will always be generated in separate files as separate classes.
 * Schema names will always be generated in form of: {{{ <message name><message suffix>Schema}}}. This is to separate names of generated models and schemas. Suffix can be defined following way (suffix term is used in postfix meaning) (options with high priority overrides options with lower priority): 
 {{{
       // from highest priority to lowest 
       option msuffix = "Suffix"; // can only be provided inside of message body
       option java_model_suffix = "Suffix" // can be provided inside of message body
       option <message name>.suffix = "Suffix for this certain message"  // in global namespace or in module properties
       option java_model_suffix = "Suffix" // in global namespace, in module properties
 }}}
 * Model names will always be generated in form of: {{{ <message package><message name><message suffix>}}}. Package is defined much alike schema Suffix. Package should be always end up with DOT.
   {{{ 
       // from highest priority to lowest 
       option mpackage = "com.package."; // can only be provided inside of message body
       option java_model_package = "com.package." // can be provided inside of message body
       option <message name>.package = "package for this certain message."  // in global namespace or in module properties
       option java_model_package = "com.package." // in global namespace, in module properties
   }}} 
 * if {{{ @Import(a="com.text.blah", b="org.text.blah", ...) }}} is specified on a message, all values of params of this attribute will be included in an import section of the file.
 * if {{{ @Transient }}} is specified on a message or enum block, it will be skipped for generation. Nothing will be generated for that.

To Be continued ...