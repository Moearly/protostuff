#summary Existing pojos or ejbs can be protobuf encoded/serialized.
#labels Featured

The *protostuff-runtime* module allows your existing pojos to be serialized to different formats.

For people who prefer not to have their messages code-generated from proto files, this fits your bill.

The advantages of using proto files is that you have explicit control of fields and their corresponding numbers (which is useful 
for schema evolution, e.g forward-backward compatibility).

With this module, the field's number is ordered according of their declaration in the pojo (top to bottom).

Forward-backward compatibility is supported via "append-only" schema evolution.
 * To add new fields, append the field in the declaration
 * To remove existing fields, annotate with @Deprecated
   
Here's an example:
{{{
    public static class Entity
    {
        int id;
        
        String name;
        
        @Deprecated
        String alias;
        
        long timestamp;
    }
}}}

Schema evolution scenario:
 * v1: 3 initial fields (id=1, name=2, alias=3)
 * v2: Added a new field (timestamp=4).
 * v3: Removed the "alias" field.

With v3, the field mapping would be (id=1, name=2, timestamp=4).  When we encounter the alias field, it is ignored by the deserializer.

The field mapping is still intact despite schema evolution ... w/c makes it forward-backward compatible to different versions.

===Usage===

_Note that you can also hand-code schemas for more customization._

{{{
   Foo foo = new Foo("foo", 1, 3.5);

   // this is lazily created and cached by RuntimeSchema
   // so its safe to call RuntimeSchema.getSchema(Foo.class) over and over
   // The getSchema method is also thread-safe
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBufer();
   
   // protostuff serialize
   try
   {
       byte[] protostuff = ProtostuffIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }

   // protostuff deserialize
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(protostuff, f, schema);
   
   // protobuf serialize
   try
   {
       byte[] protostuff = ProtobufIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }

   // protobuf deserialize
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(protobuf, f, schema);
   
   // json serialize
   boolean numeric = true;
   byte[] json = JsonIOUtil.toByteArray(foo, schema, numeric);

   // json deserialize
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(json, f, schema, numeric);
   
   // xml serialize
   byte[] xml = XmlIOUtil.toByteArray(foo, schema);

   // xml deserialize
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(xml, f, schema);
   
   // yaml serialize
   try
   {
       byte[] protostuff = YamlIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   
}}}

===Reading/Writing from/to streams===
{{{
   Foo foo = new Foo("foo", 1, 3.5);
   
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBufer();
   
   // protostuff serialize
   try
   {
       ProtostuffIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   
   // protostuff deserialize
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(inputStream, f, schema);
   
   // protobuf serialize
   try
   {
       ProtobufIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   
   // protobuf deserialize
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(inputStream, f, schema);
   
   // json serialize
   boolean numeric = true;
   JsonIOUtil.writeTo(outputStream, foo, schema, numeric);
   
   // json deserialize
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(inputStream, f, schema, numeric);
   
   // xml serialize
   XmlIOUtil.writeTo(outputStream, foo, schema);
   
   // xml deserialize
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(inputStream, f, schema);
   
   // yaml serialize
   try
   {
       YamlIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }

}}}