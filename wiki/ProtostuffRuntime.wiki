#summary Existing pojos or ejbs can be protobuf encoded/serialized.
#labels Featured

The *protostuff-runtime* module allows your existing pojos to be serialized to different formats.

For people who prefer not to have their messages code-generated from proto files, this fits your bill.

The advantages of using proto files is that you have explicit control of fields and their corresponding numbers (which is useful 
for schema evolution, e.g forward-backward compatibility).

With this module, the field's number is ordered according to their declaration in the pojo (top to bottom).

Forward-backward compatibility is supported via "append-only" schema evolution.
 * To add new fields, append the field in the declaration
 * To remove existing fields, annotate with @Deprecated
   
Here's an example:
{{{
    public class Entity
    {
        int id;
        
        String name;
        
        @Deprecated
        String alias;
        
        long timestamp;
    }
}}}

Schema evolution scenario:
 * v1: 3 initial fields (id=1, name=2, alias=3)
 * v2: Added a new field (timestamp=4).
 * v3: Removed the "alias" field.

With v3, the field mapping would be (id=1, name=2, timestamp=4).  When we encounter the alias field, it is ignored by the deserializer.

The field mapping is still intact despite schema evolution ... w/c makes it forward-backward compatible to different versions.

===Usage===

_Note that you can also hand-code schemas for more customization._

{{{
   Foo foo = new Foo("foo", 1, 3.5);

   // this is lazily created and cached by RuntimeSchema
   // so its safe to call RuntimeSchema.getSchema(Foo.class) over and over
   // The getSchema method is also thread-safe
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBuffer();
   
   /* -------- protostuff -------- */
   // ser
   try
   {
       byte[] protostuff = ProtostuffIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(protostuff, f, schema);
   
   
   /* -------- protobuf -------- */
   // ser
   try
   {
       byte[] protobuf = ProtobufIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(protobuf, f, schema);
   
   
   /* -------- json -------- */
   // ser
   boolean numeric = true;
   byte[] json = JsonIOUtil.toByteArray(foo, schema, numeric, buffer);

   // deser
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(json, f, schema, numeric);
   
    
   /* -------- xml -------- */
   // ser
   byte[] xml = XmlIOUtil.toByteArray(foo, schema);

   // deser
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(xml, f, schema);
   
   
   /* -------- yaml -------- */
   // ser
   try
   {
       byte[] yaml = YamlIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   
}}}

===Reading/Writing from/to streams===
{{{
   Foo foo = new Foo("foo", 1, 3.5);
   
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBuffer();
   
   /* -------- protostuff -------- */
   // ser
   try
   {
       ProtostuffIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(inputStream, f, schema, buffer);
   

   /* --------protobuf -------- */
   // ser
   try
   {
       ProtobufIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(inputStream, f, schema, buffer);
   
   
   /* -------- json -------- */
   // ser
   boolean numeric = false;
   JsonIOUtil.writeTo(outputStream, foo, schema, numeric, buffer);
   
   // deser
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(inputStream, f, schema, numeric, buffer);
   
   
   /* -------- xml -------- */
   // ser
   XmlIOUtil.writeTo(outputStream, foo, schema);
   
   // deser
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(inputStream, f, schema);
   
   
   /* -------- yaml -------- */
   // ser
   try
   {
       YamlIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }

}}}