#summary schemas for existing pojos/beans/objects/etc
#labels Featured

*Please use atleast protostuff-1.0.4 or later if you have raw byte array fields ({{{byte[],List<byte[]>,etc}}}). See [http://code.google.com/p/protostuff/issues/detail?id=90 Issue 90] for details.*

The *protostuff-runtime* module allows your existing pojos to be serialized to different formats.

For people who prefer not to have their messages code-generated from proto files, this fits your bill.

The preliminary modules needed:
 * protostuff-api
 * protostuff-collectionschema
 * protostuff-runtime

The advantages of using proto files is that you have explicit control of fields and their corresponding numbers (which is useful 
for schema evolution, e.g forward-backward compatibility).

With this module, the field's number is ordered according to their declaration in the pojo (top to bottom).

*Note that the order is not guaranteed on some (non-sun) vms (especially dalvik)*.

Sun jdk6 or higher is recommended for guaranteed ordering ([http://stackoverflow.com/questions/5001172/java-reflection-getting-fields-and-methods-in-declaration-order link]).

Forward-backward compatibility is supported via "append-only" schema evolution.
 * To add new fields, append the field in the declaration
 * To remove existing fields, annotate with @Deprecated
   
Here's an example:
{{{
    public final class Entity
    {
        int id;
        
        String name;
        
        @Deprecated
        String alias;
        
        long timestamp;
    }
}}}

Schema evolution scenario:
 * v1: 3 initial fields (id=1, name=2, alias=3)
 * v2: Added a new field (timestamp=4).
 * v3: Removed the "alias" field.

With v3, the field mapping would be (id=1, name=2, timestamp=4).  When we encounter the alias field, it is ignored by the deserializer.

The field mapping is still intact despite schema evolution ... w/c makes it forward-backward compatible to different versions.

==3 possible types of Schema==

Unlike a static hand-written/code-generated schema, there are 3 possible types of schema that can be used 
at runtime.  Below are the types ordered according to their efficiency and performance at runtime.

 * *Static Schema*
   * used when nested messages are concrete types.
   * compact since no extra metadata included on serialization
   * E.g 
     {{{
        public enum SortOrder
        {
            ASCENDING,
            DESCENDING;
        }

        public final class Bar
        {
            Entity entity; // the example above
            List<Long> scalarList; // any scalar type
            List<byte[]> bytesList; // byte arrays are treated as scalar fields (use >= 1.0.4)
            List<Entity> entityList;
            Map<String,byte[]> bytesMapWithScalarKeys;
            Map<String,Entity> entityMapWithScalarKeys;
            Map<SortOrder,Entity> entityMapWithEnumKeys;
            Map<Entity,Entity> entityMapWithPojoKeys;
        }
     }}}

 * *{{{DerivativeSchema}}}*
   * used when nested messages are interface/abstract types.
   * less compact since the type metadata (FQCN) is written (field number: 127) on serialization.
   * E.g
     {{{
        public interface IEntity
        {
            // getters/setters
            // this could be an abstract base class as well
        }

        public final class Baz
        {
            IEntity entity; // the example above
            List<IEntity> entityList;
            Map<String,IEntity> entityMapWithScalarKeys;
            Map<SortOrder,IEntity> entityMapWithEnumKeys;
            Map<IEntity,IEntity> entityMapWithPojoKeys;
        }

     }}}

 * *{{{ObjectSchema}}}* (dynamic)
   * used when nested messages:
     * are of type {{{java.lang.Object}}}
     * are arrays
     * don't have generics
     * are too complex
   * all necessary metadata is included on serialization to be able to deserialize the message correctly.
   * E.g
     {{{

        public final class Dynamic
        {
            Object entity;
    
            Object[] objectArray;
            int[] primitiveArray;
            Integer[] boxedArray;
            Entity[] entityArray;
            IEntity[] ientityArray;

            List noGenericsList;
            List<?> uselessGenericsList;
            List<Object> objectList;
            List<long[]> withArrayList;
    
            Map noGenericsMap;
            Map<?,?> uselessGenericsMap;
            Map<String,Object> withObjectMap;
            Map<?,SortOrder> dynamicKeyMap;
            Map<Entity,?> dynamicValueMap;
            Map<Integer[],int[]> withArrayMap;

            // and complex types
            List<List<String>> aListWithAList;
            Map<String,List<SortOrder>> complexMap;
            Map<Set<Entity>,Long> anotherComplexMap;
        }

     }}}


=== Updating fields ===

With the information above, be sure that you update your fields carefully. 

For example ... don't add/remove generics when you already have existing data because the deserialization will fail.

For scalar fields:
 * {{{int}}} can be updated to {{{long}}} (and vice versa)
   * compatible with most (if not all) formats
 * {{{String}}} can be updated to {{{byte[]}}} (and vice versa)
   * not compatible with text formats (e.g json/xml/yaml)


==Usage==

_Note that you can also hand-code schemas for more customization._

{{{
   Foo foo = new Foo("foo", 1, 3.5);

   // this is lazily created and cached by RuntimeSchema
   // so its safe to call RuntimeSchema.getSchema(Foo.class) over and over
   // The getSchema method is also thread-safe
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBuffer();
   
   /* -------- protostuff -------- (requires protostuff-core module) */
   // ser
   try
   {
       byte[] protostuff = ProtostuffIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(protostuff, f, schema);
   
   
   /* -------- protobuf -------- (requires protostuff-core module) */
   // ser
   try
   {
       byte[] protobuf = ProtobufIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(protobuf, f, schema);
   
   
   /* -------- json -------- (requires protostuff-json module)*/
   // ser
   boolean numeric = true;
   byte[] json = JsonIOUtil.toByteArray(foo, schema, numeric, buffer);

   // deser
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(json, f, schema, numeric);
   
    
   /* -------- xml -------- (requires protostuff-xml module)*/
   // ser
   byte[] xml = XmlIOUtil.toByteArray(foo, schema);

   // deser
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(xml, f, schema);
   
   
   /* -------- yaml -------- (requires protostuff-yaml module)*/
   // ser
   try
   {
       byte[] yaml = YamlIOUtil.toByteArray(foo, schema, buffer);
   }
   finally
   {
       buffer.clear();
   }
   
}}}

===Reading/Writing from/to streams===
{{{
   Foo foo = new Foo("foo", 1, 3.5);
   
   Schema<Foo> schema = RuntimeSchema.getSchema(Foo.class);
   LinkedBuffer buffer = getApplicationBuffer();
   
   /* -------- protostuff -------- (requires protostuff-core module)*/
   // ser
   try
   {
       ProtostuffIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtostuffIOUtil.mergeFrom(inputStream, f, schema, buffer);
   

   /* --------protobuf -------- (requires protostuff-core module)*/
   // ser
   try
   {
       ProtobufIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }
   // deser
   Foo f = new Foo();
   ProtobufIOUtil.mergeFrom(inputStream, f, schema, buffer);
   
   
   /* -------- json -------- (requires protostuff-json module)*/
   // ser
   boolean numeric = false;
   JsonIOUtil.writeTo(outputStream, foo, schema, numeric, buffer);
   
   // deser
   Foo f = new Foo();
   JsonIOUtil.mergeFrom(inputStream, f, schema, numeric, buffer);
   
   
   /* -------- xml -------- (requires protostuff-xml module)*/
   // ser
   XmlIOUtil.writeTo(outputStream, foo, schema);
   
   // deser
   Foo f = new Foo();
   XmlIOUtil.mergeFrom(inputStream, f, schema);
   
   
   /* -------- yaml -------- (requires protostuff-yaml module)*/
   // ser
   try
   {
       YamlIOUtil.writeTo(outputStream, foo, buffer);
   }
   finally
   {
       buffer.clear();
   }

}}}